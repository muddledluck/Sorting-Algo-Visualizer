{"ast":null,"code":"import { checkAlgo, swap } from \"../SortingComponents/SortingComponents\";\nexport function getHeapSortAnimations(array) {\n  const animations = [];\n\n  if (array.length <= 1) {\n    return array;\n  }\n\n  const auxiliaryArray = array.slice();\n  heapSortHelper(auxiliaryArray, array.length, animations);\n  const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n  array = auxiliaryArray;\n  console.log(\"alog is Correct(Heap Sort)? \", checkAlgo(array, javaScriptSortedArray));\n  return animations;\n}\n\nfunction heapSortHelper(auxiliaryArray, arrLength, animations) {\n  // Build a maxheap\n  const midIdx = Math.floor(arrLength / 2 - 1);\n\n  for (let i = midIdx; i >= 0; i--) {\n    heapify(auxiliaryArray, arrLength, i, animations);\n  } // One by one  extract elements\n\n\n  for (let i = arrLength - 1; i > 0; i--) {\n    animations.push([i, 0]);\n    animations.push([0, i]);\n    animations.push([i, auxiliaryArray[0]]);\n    animations.push([0, auxiliaryArray[i]]);\n    swap(auxiliaryArray, i, 0);\n    heapify(auxiliaryArray, i, 0, animations);\n  }\n}\n\nfunction heapify(auxiliaryArray, arrLength, current, animations) {\n  let largest = current; // Initialize largest as root\n\n  const left = 2 * current + 1;\n  const right = 2 * current + 2; // Check if left child of root exists and is greater than root\n\n  if (left < arrLength && auxiliaryArray[current] < auxiliaryArray[left]) {\n    largest = left;\n  } // Check if right child of root exists and is greater than root\n\n\n  if (right < arrLength && auxiliaryArray[largest] < auxiliaryArray[right]) {\n    largest = right;\n  } // Change root, if needed\n\n\n  if (largest !== current) {\n    animations.push([current, largest]);\n    animations.push([largest, current]);\n    animations.push([current, auxiliaryArray[largest]]);\n    animations.push([largest, auxiliaryArray[current]]);\n    swap(auxiliaryArray, current, largest);\n    heapify(auxiliaryArray, arrLength, largest, animations);\n  }\n}","map":{"version":3,"sources":["F:/Coding/React/Sorting-Algo-Visualizer/src/components/Algorithms/HeapSortAnimation/HeapSortAnimation.js"],"names":["checkAlgo","swap","getHeapSortAnimations","array","animations","length","auxiliaryArray","slice","heapSortHelper","javaScriptSortedArray","sort","a","b","console","log","arrLength","midIdx","Math","floor","i","heapify","push","current","largest","left","right"],"mappings":"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","sourcesContent":["import { checkAlgo, swap } from \"../SortingComponents/SortingComponents\";\r\n\r\nexport function getHeapSortAnimations(array){\r\n\tconst animations = [];\r\n\tif (array.length <= 1){\r\n\t\treturn array;\r\n\t}\r\n\tconst auxiliaryArray = array.slice();\r\n\theapSortHelper(auxiliaryArray, array.length, animations);\r\n\tconst javaScriptSortedArray = array.slice().sort((a, b) => a - b);\r\n\tarray = auxiliaryArray;\r\n\tconsole.log(\"alog is Correct(Heap Sort)? \", checkAlgo(array, javaScriptSortedArray))\r\n\treturn animations;\r\n}\r\n\r\nfunction heapSortHelper(auxiliaryArray, arrLength, animations){\r\n\t// Build a maxheap\r\n\tconst midIdx = Math.floor((arrLength / 2) - 1);\r\n\tfor (let i = midIdx; i >= 0; i--){\r\n\t\theapify(auxiliaryArray, arrLength, i, animations);\r\n\t}\r\n\r\n\t// One by one  extract elements\r\n\tfor (let i = arrLength - 1; i > 0; i--){\r\n\t\tanimations.push([i, 0]);\r\n\t\tanimations.push([0, i]);\r\n\t\tanimations.push([i, auxiliaryArray[0]]);\r\n\t\tanimations.push([0, auxiliaryArray[i]])\r\n\t\tswap(auxiliaryArray, i, 0);\r\n\t\theapify(auxiliaryArray, i, 0, animations);\r\n\t}\r\n}\r\nfunction heapify(auxiliaryArray, arrLength, current, animations){\r\n\tlet largest = current; // Initialize largest as root\r\n\tconst left = 2 * current + 1; \r\n\tconst right = 2 * current + 2;\r\n\r\n\t// Check if left child of root exists and is greater than root\r\n\tif (left < arrLength && auxiliaryArray[current] < auxiliaryArray[left]){\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// Check if right child of root exists and is greater than root\r\n\tif (right < arrLength && auxiliaryArray[largest] < auxiliaryArray[right]){\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// Change root, if needed\r\n\tif (largest !== current){\r\n\t\tanimations.push([current, largest]);\r\n\t\tanimations.push([largest, current]);\r\n\t\tanimations.push([current, auxiliaryArray[largest]]);\r\n\t\tanimations.push([largest, auxiliaryArray[current]]);\r\n        swap(auxiliaryArray, current, largest);\r\n\t\theapify(auxiliaryArray, arrLength, largest, animations);\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}